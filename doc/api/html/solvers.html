
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>odespy.solvers &mdash; Odespy API 0.2 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Odespy API 0.2 documentation" href="index.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">Odespy API 0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-odespy.solvers">
<span id="odespy-solvers"></span><h1><a class="reference internal" href="#module-odespy.solvers" title="odespy.solvers"><tt class="xref py py-mod docutils literal"><span class="pre">odespy.solvers</span></tt></a><a class="headerlink" href="#module-odespy.solvers" title="Permalink to this headline">¶</a></h1>
<p>This module contains the base class <tt class="docutils literal"><span class="pre">Solver</span></tt>
package and the implementations of many subclasses.</p>
<p>A new non-adaptive time-stepping scheme can often be implemented by
just subclassing <tt class="docutils literal"><span class="pre">Solver</span></tt> and writing the <tt class="docutils literal"><span class="pre">advance</span></tt> method
to define the time-stepping scheme. Here is how the 4th-order
Runge-Kutta is implemented:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">RK4</span><span class="p">(</span><span class="n">Solver</span><span class="p">):</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;Explicit 4th-order Runge-Kutta method&quot;</span>

    <span class="k">def</span> <span class="nf">advance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">dt2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">K1</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">K2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">K1</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt2</span><span class="p">)</span>
        <span class="n">K3</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">K2</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt2</span><span class="p">)</span>
        <span class="n">K4</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">K3</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">u_new</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">K1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">K2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">K3</span> <span class="o">+</span> <span class="n">K4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">u_new</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">quick_description</span></tt> string is needed for the class to appear
in the package&#8217;s table of contents.</p>
<p>Implicit solver: See examples in the <tt class="docutils literal"><span class="pre">solver.py</span></tt> file,
class <tt class="docutils literal"><span class="pre">BackwardEuler</span></tt>, for instance.</p>
<p>Adaptive solver: See examples in the <tt class="docutils literal"><span class="pre">solver.py</span></tt> file, class <tt class="docutils literal"><span class="pre">RKFehlberg</span></tt>,
for instance.</p>
<p><em>Wrapping other packages</em>.
This section is for developers who intend to wrap an existing
package and integrate with the present one..</p>
<p>If the original package is not written in Python language, developers
need to apply some specific tools (like F2PY, Cython, or SWIG) to create an
extension module to make the package accessible from Python
code.</p>
<p>On the other hand, if the original package is also a Python software,
developers need to install and import (in <tt class="docutils literal"><span class="pre">initialize</span></tt>) the desired
package as a Python module and just write a class in the <tt class="docutils literal"><span class="pre">Solver</span></tt>
hierarchy that calls the proper functions in the package. See the
classes <tt class="docutils literal"><span class="pre">odefun_sympy</span></tt> and <tt class="docutils literal"><span class="pre">ode_scipy</span></tt> (and its subclasses).</p>
<p>By an attempt to import these necessary modules (often set in method
initialize()), we can check whether the necessary dependencies are
installed properly.</p>
<p><em>Definition of parameters and their properties</em>.
Each solver has a set of specific parameters depending on its
underlying method. For example, adaptive solvers will be more
likely to apply (many) attributes for step-size control.
When integrating a new method, first search in the <tt class="docutils literal"><span class="pre">_parameters</span></tt>
dictionary in <tt class="docutils literal"><span class="pre">solver.py</span></tt> if some parameters can be reused
for the new solver. New parameters are added to the <tt class="docutils literal"><span class="pre">_parameters</span></tt>
dictionary, either in the <tt class="docutils literal"><span class="pre">solver.py</span></tt> or by importing <tt class="docutils literal"><span class="pre">solver</span></tt>
and updating <tt class="docutils literal"><span class="pre">solver._parameters</span></tt>, see <tt class="docutils literal"><span class="pre">rkc.py</span></tt> for an example.</p>
<p>Each solver class lists the required and optional parameters
it needs in the class variables <tt class="docutils literal"><span class="pre">_optional_parameters</span></tt> and
<tt class="docutils literal"><span class="pre">_required_parameters</span></tt>. Very often these lists are inherited,
or just a few new parameters are added to the list already
defined in the superclass.</p>
<p>Sometimes values of parameters (or other properties) need to be
changed in a solver, e.g., because there are certain relations between
various parameters. Appropriate adjustments and checks are done in the
method <tt class="docutils literal"><span class="pre">initialize_for_solve</span></tt>, which is called in the beginning of
the &#8220;solve&#8221; process (before any computations take place).  Many
classes provide examples on this, e.g., class <tt class="docutils literal"><span class="pre">RKC</span></tt> in <tt class="docutils literal"><span class="pre">rkc.py</span></tt>.
This particular class shows how to generate input parameters
to the Fortran code that are not given by the user, but automatically
derived in the Python code from other data.</p>
<p>Another method that is called from <tt class="docutils literal"><span class="pre">solve</span></tt> is <tt class="docutils literal"><span class="pre">validate_data</span></tt>. The
solver class can use this method to check for consistency of data
structures before starting the numerical computations.  As an example,
the class <tt class="docutils literal"><span class="pre">Lsodes</span></tt> in the <tt class="docutils literal"><span class="pre">odepack.py</span></tt> file imposes relations
between the input data: two input integer arrays <tt class="docutils literal"><span class="pre">ia</span></tt> and <tt class="docutils literal"><span class="pre">ja</span></tt>
must be input simultaneously, <tt class="docutils literal"><span class="pre">len(ia)</span> <span class="pre">==</span> <span class="pre">neq</span> <span class="pre">+</span> <span class="pre">1</span></tt>, and <tt class="docutils literal"><span class="pre">ia[neq]</span> <span class="pre">=</span>
<span class="pre">len(ja)</span></tt>. These checks are done in Python before calling the Fortran
solver.</p>
<p><em>The solve and advance methods</em>.
Simple methods can just implement <tt class="docutils literal"><span class="pre">advance</span></tt> to bring the solution
one step forward in time. The existing <tt class="docutils literal"><span class="pre">solve</span></tt> method derived from
the superclass is general enough to administer the whole solution
process.</p>
<p>Adaptive solvers will typically think of <tt class="docutils literal"><span class="pre">advance</span></tt> as bringing the
solution to the next user-desired time level, using an unknown set of
smaller time steps whose sizes must be determined. Then there will
hence be a time loop within <tt class="docutils literal"><span class="pre">advance</span></tt>, while the outer time loop in
<tt class="docutils literal"><span class="pre">solve</span></tt> takes care of the stepping between the user-desired time
levels. (The simplest methods just takes one step between the
user-desired time levels.)</p>
<p>When wrapping solvers in external software, it is occasionally not
feasible to implement <tt class="docutils literal"><span class="pre">advance</span></tt> because one wants to rely on the
software&#8217;s ability to solve the whole ODE problem. Then it is more
natural to write a new <tt class="docutils literal"><span class="pre">solve</span></tt> method (using <tt class="docutils literal"><span class="pre">Solver.solve</span></tt> as
model) and call up the solve functionality in the external
software. Class <tt class="docutils literal"><span class="pre">odefun_sympy</span></tt> provides an example. On the other
hand, the wrappers for the <tt class="docutils literal"><span class="pre">scipy</span></tt> solvers (<tt class="docutils literal"><span class="pre">vode</span></tt> for instance)
applies <tt class="docutils literal"><span class="pre">solve</span></tt> from the present package and the <tt class="docutils literal"><span class="pre">scipy</span></tt> functions
for doing one (adaptive) time step, called in the <tt class="docutils literal"><span class="pre">advance</span></tt> method.</p>
<dl class="class">
<dt id="odespy.solvers.AdamsBashMoulton2">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">AdamsBashMoulton2</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashMoulton2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Two-step (3rd-order) Adams-Bashforth method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">predictor</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">12.</span><span class="o">*</span><span class="p">(</span><span class="mf">23.</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">16</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                    <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
<span class="n">corrector</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">12.</span><span class="o">*</span><span class="p">(</span><span class="mf">8.</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                    <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">predictor</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>for constant time step dt.</p>
<p>RK2 is used as default solver for first steps.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>start_method</td>
<td>Method for the first steps in multi-step solvers.
(default: RK2)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdamsBashMoulton2.advance" title="odespy.solvers.AdamsBashMoulton2.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.AdamsBashMoulton2.initialize_for_solve" title="odespy.solvers.AdamsBashMoulton2.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdamsBashMoulton2.validate_data" title="odespy.solvers.AdamsBashMoulton2.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.AdamsBashMoulton2.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton2.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashMoulton2.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashMoulton2.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton2.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashMoulton2.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashMoulton2.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton2.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.AdamsBashMoulton2.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 2nd-order Adams-Bashforth-Moulton method'</em><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton2.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashMoulton2.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashMoulton2.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton2.validate_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.AdamsBashMoulton3">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">AdamsBashMoulton3</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashMoulton3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Three-step (4th-order) Adams-Bashforth method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">predictor</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">24.</span><span class="o">*</span><span class="p">(</span><span class="mf">55.</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">59</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                           <span class="mi">37</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">]))</span>
<span class="n">corrector</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">24.</span><span class="o">*</span><span class="p">(</span><span class="mf">19.</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                           <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">predictor</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>for constant time step dt.</p>
<p>RK2 is used as default solver for first steps.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>start_method</td>
<td>Method for the first steps in multi-step solvers.
(default: RK2)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdamsBashMoulton3.advance" title="odespy.solvers.AdamsBashMoulton3.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.AdamsBashMoulton3.initialize_for_solve" title="odespy.solvers.AdamsBashMoulton3.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdamsBashMoulton3.validate_data" title="odespy.solvers.AdamsBashMoulton3.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.AdamsBashMoulton3.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton3.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashMoulton3.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashMoulton3.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton3.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashMoulton3.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashMoulton3.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton3.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.AdamsBashMoulton3.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 3rd-order Adams-Bashforth-Moulton method'</em><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton3.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashMoulton3.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashMoulton3.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashMoulton3.validate_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.AdamsBashforth2">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">AdamsBashforth2</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Second-order Adams-Bashforth method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>for constant time step dt.</p>
<p>RK2 is used as default solver in first step.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>start_method</td>
<td>Method for the first steps in multi-step solvers.
(default: RK2)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdamsBashforth2.advance" title="odespy.solvers.AdamsBashforth2.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.AdamsBashforth2.initialize_for_solve" title="odespy.solvers.AdamsBashforth2.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdamsBashforth2.validate_data" title="odespy.solvers.AdamsBashforth2.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td>Check that the time steps are constant.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.AdamsBashforth2.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.AdamsBashforth2.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashforth2.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth2.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth2.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashforth2.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth2.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth2.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.AdamsBashforth2.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 2nd-order Adams-Bashforth method'</em><a class="headerlink" href="#odespy.solvers.AdamsBashforth2.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashforth2.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth2.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth2.validate_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that the time steps are constant.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.AdamsBashforth3">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">AdamsBashforth3</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Third-order Adams-Bashforth method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">12.</span><span class="o">*</span><span class="p">(</span><span class="mi">23</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">16</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
</pre></div>
</div>
<p>for constant time step dt.</p>
<p>RK2 is used as default solver for first steps.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>start_method</td>
<td>Method for the first steps in multi-step solvers.
(default: RK2)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdamsBashforth3.advance" title="odespy.solvers.AdamsBashforth3.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.AdamsBashforth3.initialize_for_solve" title="odespy.solvers.AdamsBashforth3.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdamsBashforth3.validate_data" title="odespy.solvers.AdamsBashforth3.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.AdamsBashforth3.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.AdamsBashforth3.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashforth3.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth3.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth3.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashforth3.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth3.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth3.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.AdamsBashforth3.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 3rd-order Adams-Bashforth method'</em><a class="headerlink" href="#odespy.solvers.AdamsBashforth3.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashforth3.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth3.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth3.validate_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.AdamsBashforth4">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">AdamsBashforth4</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Fourth-order Adams-Bashforth method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">24.</span><span class="o">*</span><span class="p">(</span><span class="mf">55.</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">59</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                        <span class="mi">37</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p>for constant time step dt.</p>
<p>RK2 is used as default solver for first steps.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>start_method</td>
<td>Method for the first steps in multi-step solvers.
(default: RK2)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdamsBashforth4.advance" title="odespy.solvers.AdamsBashforth4.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.AdamsBashforth4.initialize_for_solve" title="odespy.solvers.AdamsBashforth4.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdamsBashforth4.validate_data" title="odespy.solvers.AdamsBashforth4.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.AdamsBashforth4.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.AdamsBashforth4.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashforth4.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth4.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth4.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashforth4.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth4.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth4.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.AdamsBashforth4.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 4th-order Adams-Bashforth method'</em><a class="headerlink" href="#odespy.solvers.AdamsBashforth4.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdamsBashforth4.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdamsBashforth4.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdamsBashforth4.validate_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.Adaptive">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">Adaptive</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Adaptive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Adaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Superclass for adaptive solvers.    
Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>Advance solution one time step.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Adaptive.initialize_for_solve" title="odespy.solvers.Adaptive.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.Adaptive.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.Adaptive.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.Adaptive.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Adaptive.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Adaptive.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.AdaptiveResidual">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">AdaptiveResidual</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdaptiveResidual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdaptiveResidual" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Adaptive" title="odespy.solvers.Adaptive"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Adaptive</span></tt></a></p>
<p>Designed for educational purposes to demonstrate a possible
adaptive strategy.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-odd"><td>solver</td>
<td>Name of solver class in solvers that need an extra
solver (e.g., AdaptiveResidual). (default: RK4)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>Advance solution one time step.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.AdaptiveResidual.residual" title="odespy.solvers.AdaptiveResidual.residual"><tt class="xref py py-obj docutils literal"><span class="pre">residual</span></tt></a>(u_n,&nbsp;u_next,&nbsp;t_n,&nbsp;t_next)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.AdaptiveResidual.solve" title="odespy.solvers.AdaptiveResidual.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odespy.solvers.AdaptiveResidual.__init__">
<tt class="descname">__init__</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdaptiveResidual.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdaptiveResidual.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.AdaptiveResidual.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.AdaptiveResidual.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.AdaptiveResidual.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Very simple adaptive strategy based on the residual'</em><a class="headerlink" href="#odespy.solvers.AdaptiveResidual.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdaptiveResidual.residual">
<tt class="descname">residual</tt><big>(</big><em>u_n</em>, <em>u_next</em>, <em>t_n</em>, <em>t_next</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdaptiveResidual.residual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdaptiveResidual.residual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.AdaptiveResidual.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#AdaptiveResidual.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.AdaptiveResidual.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.Backward2Step">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">Backward2Step</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Backward2Step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Backward2Step" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.SolverImplicit" title="odespy.solvers.SolverImplicit"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.SolverImplicit</span></tt></a></p>
<p>Implicit Backward Euler method with 2 steps:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span>
</pre></div>
</div>
<p>The 1st-order Backward Euler method is used for the first step.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept
in memory; if True, a default filename tmp_odspy.dat
is used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default:
None)</td>
</tr>
<tr class="row-even"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacobian.
(default: 0.0001)</td>
</tr>
<tr class="row-even"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver. (default: Picard)</td>
</tr>
<tr class="row-odd"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default: 25)</td>
</tr>
<tr class="row-even"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default:
0.0001)</td>
</tr>
<tr class="row-odd"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solution +
(1-r)*old_solution (default: 1.0)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Backward2Step.Newton_system" title="odespy.solvers.Backward2Step.Newton_system"><tt class="xref py py-obj docutils literal"><span class="pre">Newton_system</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Backward2Step.Picard_update" title="odespy.solvers.Backward2Step.Picard_update"><tt class="xref py py-obj docutils literal"><span class="pre">Picard_update</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odespy.solvers.Backward2Step.Newton_system">
<tt class="descname">Newton_system</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Backward2Step.Newton_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Backward2Step.Newton_system" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.Backward2Step.Picard_update">
<tt class="descname">Picard_update</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Backward2Step.Picard_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Backward2Step.Picard_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.Backward2Step.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.Backward2Step.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.Backward2Step.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Implicit 2nd-order Backward Euler method'</em><a class="headerlink" href="#odespy.solvers.Backward2Step.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.BackwardEuler">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">BackwardEuler</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#BackwardEuler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.BackwardEuler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.SolverImplicit" title="odespy.solvers.SolverImplicit"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.SolverImplicit</span></tt></a></p>
<p>Implicit Backward Euler method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The nonlinear system is solved by Newton or Picard iteration.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept
in memory; if True, a default filename tmp_odspy.dat
is used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default:
None)</td>
</tr>
<tr class="row-even"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacobian.
(default: 0.0001)</td>
</tr>
<tr class="row-even"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver. (default: Picard)</td>
</tr>
<tr class="row-odd"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default: 25)</td>
</tr>
<tr class="row-even"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default:
0.0001)</td>
</tr>
<tr class="row-odd"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solution +
(1-r)*old_solution (default: 1.0)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.BackwardEuler.Newton_system" title="odespy.solvers.BackwardEuler.Newton_system"><tt class="xref py py-obj docutils literal"><span class="pre">Newton_system</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.BackwardEuler.Picard_update" title="odespy.solvers.BackwardEuler.Picard_update"><tt class="xref py py-obj docutils literal"><span class="pre">Picard_update</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odespy.solvers.BackwardEuler.Newton_system">
<tt class="descname">Newton_system</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#BackwardEuler.Newton_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.BackwardEuler.Newton_system" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.BackwardEuler.Picard_update">
<tt class="descname">Picard_update</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#BackwardEuler.Picard_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.BackwardEuler.Picard_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.BackwardEuler.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.BackwardEuler.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.BackwardEuler.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Implicit 1st-order Backward Euler method'</em><a class="headerlink" href="#odespy.solvers.BackwardEuler.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.Dop853">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">Dop853</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Dop853"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Dop853" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.ode_scipy" title="odespy.solvers.ode_scipy"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.ode_scipy</span></tt></a></p>
<p>Wrapper for scipy.integrate.ode.dop853, which applies the
Dormand&amp;Prince method of order 8(5,3), based on the Fortran
implementation by Hairer and Wanner.
See <a class="reference external" href="http://www.unige.ch/~hairer/software.html">http://www.unige.ch/~hairer/software.html</a>.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step. (default:
1000)</td>
</tr>
<tr class="row-odd"><td>ifactor</td>
<td>Maximum factor for increasing the step size (default: 2)</td>
</tr>
<tr class="row-even"><td>dfactor</td>
<td>Maximum factor for decreasing the step size (default:
0.5)</td>
</tr>
<tr class="row-odd"><td>beta</td>
<td>Beta argument for stabilized step size control in
Dormand&amp;Prince methods from scipy</td>
</tr>
<tr class="row-even"><td>safety</td>
<td>Safety factor on new step selection (default: 0.9)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.Dop853.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.Dop853.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.Dop853.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Adaptive Dormand &amp; Prince method of order 8(5,3) (scipy)'</em><a class="headerlink" href="#odespy.solvers.Dop853.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.Dopri5">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">Dopri5</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Dopri5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Dopri5" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.ode_scipy" title="odespy.solvers.ode_scipy"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.ode_scipy</span></tt></a></p>
<p>Wrapper for scipy.integrate.ode.dopri5, which applies the
Dormand&amp;Prince method of order 5(4), based on the Fortran
implementation by Hairer and Wanner.
See <a class="reference external" href="http://www.unige.ch/~hairer/software.html">http://www.unige.ch/~hairer/software.html</a>.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step. (default:
1000)</td>
</tr>
<tr class="row-odd"><td>ifactor</td>
<td>Maximum factor for increasing the step size (default: 2)</td>
</tr>
<tr class="row-even"><td>dfactor</td>
<td>Maximum factor for decreasing the step size (default:
0.5)</td>
</tr>
<tr class="row-odd"><td>beta</td>
<td>Beta argument for stabilized step size control in
Dormand&amp;Prince methods from scipy</td>
</tr>
<tr class="row-even"><td>safety</td>
<td>Safety factor on new step selection (default: 0.9)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.Dopri5.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.Dopri5.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.Dopri5.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Dormand &amp; Prince method of order 5(4) (scipy)'</em><a class="headerlink" href="#odespy.solvers.Dopri5.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.Euler">
<tt class="descclassname">odespy.solvers.</tt><tt class="descname">Euler</tt><a class="headerlink" href="#odespy.solvers.Euler" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#odespy.solvers.ForwardEuler" title="odespy.solvers.ForwardEuler"><tt class="xref py py-class docutils literal"><span class="pre">ForwardEuler</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="odespy.solvers.ForwardEuler">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">ForwardEuler</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#ForwardEuler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.ForwardEuler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Forward Euler scheme:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.ForwardEuler.advance" title="odespy.solvers.ForwardEuler.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.ForwardEuler.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.ForwardEuler.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.ForwardEuler.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#ForwardEuler.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.ForwardEuler.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.ForwardEuler.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'The simple explicit (forward) Euler scheme'</em><a class="headerlink" href="#odespy.solvers.ForwardEuler.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.Heun">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">Heun</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Heun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Heun" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Heun&#8217;s method, also known as an RungeKutta2 or Trapezoidal method.
Basically, it is a central difference method, with one
iteration and the Forward Euler scheme as start value.
In this sense, it is a predictor-corrector method.</p>
<p>Scheme:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Heun.advance" title="odespy.solvers.Heun.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.Heun.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.Heun.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.Heun.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Heun.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Heun.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.Heun.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = &quot;Heun's explicit method (similar to RK2)&quot;</em><a class="headerlink" href="#odespy.solvers.Heun.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.Leapfrog">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">Leapfrog</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Leapfrog"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Leapfrog" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Leapfrog scheme:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dt2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Forward Euler is used for the first step.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Leapfrog.advance" title="odespy.solvers.Leapfrog.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.Leapfrog.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.Leapfrog.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.Leapfrog.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Leapfrog.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Leapfrog.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.Leapfrog.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Standard explicit Leapfrog scheme'</em><a class="headerlink" href="#odespy.solvers.Leapfrog.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.LeapfrogFiltered">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">LeapfrogFiltered</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#LeapfrogFiltered"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.LeapfrogFiltered" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>The standard Leapfrog scheme reads:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dt2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Forward Euler is used for the first step.
Since Leapfrog gives oscillatory solutions, this class
applies a common filtering technique:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>with gamma=0.6 as in the NCAR Climate Model.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.LeapfrogFiltered.advance" title="odespy.solvers.LeapfrogFiltered.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.LeapfrogFiltered.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.LeapfrogFiltered.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.LeapfrogFiltered.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#LeapfrogFiltered.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.LeapfrogFiltered.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.LeapfrogFiltered.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Filtered Leapfrog scheme'</em><a class="headerlink" href="#odespy.solvers.LeapfrogFiltered.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.MidpointImplicit">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">MidpointImplicit</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#MidpointImplicit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.MidpointImplicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.SolverImplicit" title="odespy.solvers.SolverImplicit"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.SolverImplicit</span></tt></a></p>
<p>Midpoint Implicit method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
</pre></div>
</div>
<p>The nonlinear system is solved by Picard or Newton iteration.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept
in memory; if True, a default filename tmp_odspy.dat
is used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default:
None)</td>
</tr>
<tr class="row-even"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacobian.
(default: 0.0001)</td>
</tr>
<tr class="row-even"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver. (default: Picard)</td>
</tr>
<tr class="row-odd"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default: 25)</td>
</tr>
<tr class="row-even"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default:
0.0001)</td>
</tr>
<tr class="row-odd"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solution +
(1-r)*old_solution (default: 1.0)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.MidpointImplicit.Newton_system" title="odespy.solvers.MidpointImplicit.Newton_system"><tt class="xref py py-obj docutils literal"><span class="pre">Newton_system</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.MidpointImplicit.Picard_update" title="odespy.solvers.MidpointImplicit.Picard_update"><tt class="xref py py-obj docutils literal"><span class="pre">Picard_update</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odespy.solvers.MidpointImplicit.Newton_system">
<tt class="descname">Newton_system</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#MidpointImplicit.Newton_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.MidpointImplicit.Newton_system" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.MidpointImplicit.Picard_update">
<tt class="descname">Picard_update</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#MidpointImplicit.Picard_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.MidpointImplicit.Picard_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.MidpointImplicit.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.MidpointImplicit.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.MidpointImplicit.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Implicit 2nd-order Midpoint method'</em><a class="headerlink" href="#odespy.solvers.MidpointImplicit.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.MidpointIter">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">MidpointIter</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#MidpointIter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.MidpointIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>A midpoint/central difference method with max_iter fixed-point
iterations to solve the nonlinear system.
The Forward Euler scheme is recovered if max_iter=1 and f(u,t)
is independent of t. For max_iter=2 we have the Heun/RK2 scheme.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default: 25)</td>
</tr>
<tr class="row-odd"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default: 0.0001)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.MidpointIter.adjust_parameters" title="odespy.solvers.MidpointIter.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.MidpointIter.advance" title="odespy.solvers.MidpointIter.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.MidpointIter.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.MidpointIter.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.MidpointIter.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#MidpointIter.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.MidpointIter.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.MidpointIter.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#MidpointIter.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.MidpointIter.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.MidpointIter.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 2nd-order iterated Midpoint method'</em><a class="headerlink" href="#odespy.solvers.MidpointIter.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.MySolver">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">MySolver</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#MySolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.MySolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Users can define a solver with supplying a function
myadvance(), and make use of all possible parameters
in this module:</p>
<div class="highlight-python"><pre>myadvance(MySolver_instance)  --&gt;  return u_new</pre>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">myadvance_</span><span class="p">(</span><span class="n">ms</span><span class="p">):</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">atol</span>
    <span class="c"># All class attributes can be obtained</span>
    <span class="n">u_new</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">u_new</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">udot</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">udot</span>

<span class="n">method</span> <span class="o">=</span> <span class="n">MySolver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">myadvance</span><span class="o">=</span><span class="n">myadvance_</span><span class="p">)</span>
<span class="n">method</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
<tr class="row-odd"><td>myadvance</td>
<td>User supplied function to advance current solution one step
forward. See documents of class MySolver.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>nsteps</td>
<td>Max no of internal solver steps per time step.
(default: 1000)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>method_order</td>
<td>Method order for user-defined method if known.A
integer for 1-level methods, or a pair of   integer
for 2-levels methods.</td>
</tr>
<tr class="row-even"><td>g_f77</td>
<td><p class="first">Fortran subroutine for g.
This subroutine has the signature:</p>
<div class="last highlight-python"><pre>      subroutine g_f77(neq, t, u, ng, groot)
Cf2py intent(hide) neq
Cf2py optional, intent(hide) ng
Cf2py intent(in) t, u
Cf2py intent(out) groot
      integer neq, ng
      double precision t, u, groot
      dimension u(neq), groot(ng)
      groot = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>use_special</td>
<td>Switch for using special times</td>
</tr>
<tr class="row-even"><td>ia</td>
<td>Integer array with length neq+1 which contains
starting locations in ja of the descriptions
for columns 1...neq. ia(1) == 1. The last element
ia[neq+1] should equal to the total number of
nonzero locations assumed.
For each column j = 1...neq, the values of the
row index i in column j, where a nonzero element
may occur, are given by i == ja(k) where ia(j) &lt;=&#8217;
k &lt; ia(j+1).</td>
</tr>
<tr class="row-odd"><td>dfactor</td>
<td>Maximum factor for decreasing the step size (default:
0.5)</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default:
None)</td>
</tr>
<tr class="row-even"><td>mb</td>
<td>Block size. Describe the block-tridiagonal form of
matrix A together with nb.</td>
</tr>
<tr class="row-odd"><td>myadvance</td>
<td>User supplied function to advance current solution one
step forward. See documents of class MySolver.</td>
</tr>
<tr class="row-even"><td>res</td>
<td>User-supplied function to calculate the residual
vector, defined by r =  g(u,t) - A(u,t) * s.
Used in the linearly implicit solvers: Lsodi,
Lsodis, Lsoibt. The <tt class="docutils literal"><span class="pre">res</span></tt> function has the
signature <tt class="docutils literal"><span class="pre">res(u,t,s,ires)</span></tt> and returns
the tuple <tt class="docutils literal"><span class="pre">(r,ires)</span></tt>, where <tt class="docutils literal"><span class="pre">ires</span></tt> is an
int. On input, ires indicates how ODEPACK would use
the returned array &#8220;r&#8221;: <tt class="docutils literal"><span class="pre">ires=1</span></tt> means the full
residual exactly, <tt class="docutils literal"><span class="pre">ires=2</span></tt> means that <tt class="docutils literal"><span class="pre">r</span></tt> is
used only to compute the Jacobian dr/du by finite
differences.
<tt class="docutils literal"><span class="pre">res</span></tt> should set the flag <tt class="docutils literal"><span class="pre">ires</span></tt> if it encounters
a halt condition or illegal input. Otherwise, it
should not be reset. On output, the value 1 or -1
represents a normal return.</td>
</tr>
<tr class="row-odd"><td>nb</td>
<td>Number of blocks in the main diagonal.
In each of the nb block-rows of the matrix P
(each consisting of mb consecutive rows), the
nonzero elements are to lie in three
consecutive mb by mb blocks.  In block-rows 2
through nb-1, these are centered about the
main diagonal. In block rows 1 and nb, they
are the diagonal blocks and the two blocks
adjacent to the diagonal block.  (Thus block
positions (1,3) and (nb,nb-2) can be nonzero.)
Require: mb&gt;=1, nb&gt;=4, mb*nb==neq.</td>
</tr>
<tr class="row-even"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacobian.
(default: 0.0001)</td>
</tr>
<tr class="row-odd"><td>ng</td>
<td>No of components in constraint function g.</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-even"><td>safety</td>
<td>Safety factor on new step selection (default: 0.9)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221;. (default: adams)</td>
</tr>
<tr class="row-even"><td>stiff</td>
<td>Boolean flag to indicate stiffness.</td>
</tr>
<tr class="row-odd"><td>butcher_tableau</td>
<td>2d-array which contains the butcher table for user-
supplied Runge-Kutta method. (n,n) array for 1-level
Runge-Kutta methods.(n+1,n) array for 2-level Runge-
Kutta methods.</td>
</tr>
<tr class="row-even"><td>ode_method</td>
<td>solver type: &#8220;adams&#8221; or &#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-odd"><td>theta</td>
<td>Weight in [0,1] used for &#8220;theta-rule&#8221; finite
difference approx. (default: 0.5)</td>
</tr>
<tr class="row-even"><td>order</td>
<td>Maximum order used by the integrator (&lt;= 12 for
&#8220;adams&#8221;, &lt;= 5 for &#8220;bdf&#8221;). (default: 4)</td>
</tr>
<tr class="row-odd"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-even"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-odd"><td>jac_constant</td>
<td>Flag to show whether Jacobian is constant, 0 (false)
or 1 (true) (default: 0)</td>
</tr>
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default: 25)</td>
</tr>
<tr class="row-odd"><td>f_f77</td>
<td><p class="first">Fortran subroutine for f.
This subroutine has the signature:</p>
<div class="last highlight-python"><pre>      subroutine f_f77(neq,t,u,udot)
Cf2py intent(hide)   neq
Cf2py intent(out)    udot
      integer neq
      double precision t,u(neq),udot(neq)
      udot = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>jac_banded</td>
<td>Function for Jacobian in banded matrix form.
Used in Lsode, Lsoda, Lsodar.
<tt class="docutils literal"><span class="pre">jac_banded(u,t,ml,mu)</span></tt> returns df/du as an
array of size <tt class="docutils literal"><span class="pre">neq</span></tt> times <tt class="docutils literal"><span class="pre">ml+mu+1</span></tt>.</td>
</tr>
<tr class="row-odd"><td>beta</td>
<td>Beta argument for stabilized step size control in
Dormand&amp;Prince methods from scipy</td>
</tr>
<tr class="row-even"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-odd"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solution +
(1-r)*old_solution (default: 1.0)</td>
</tr>
<tr class="row-even"><td>odelab_solver</td>
<td>Name of Solver class in odelab (default: RungeKutta4)</td>
</tr>
<tr class="row-odd"><td>solver</td>
<td>Name of solver class in solvers that need an extra
solver (e.g., AdaptiveResidual). (default: RK4)</td>
</tr>
<tr class="row-even"><td>ja</td>
<td>Integer array containing the row indices where
the nonzero elements occur, in columnwise
order. Describes the sparsity matrix structure
together with ia.
In Lsodes, ia and ja describe the structure of
Jacobian matrix; while in Lsodis, ia and ja are
used to describe the structure of matrix A.</td>
</tr>
<tr class="row-odd"><td>init_step</td>
<td>Fixed step size for time mesh.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-odd"><td>g</td>
<td>Callable object to define constraint functions.
<tt class="docutils literal"><span class="pre">g(u,</span> <span class="pre">t)</span></tt> returns a vector of the values of the constraints
(left-hand sides in the constraint equations).</td>
</tr>
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
<tr class="row-odd"><td>start_method</td>
<td>Method for the first steps in multi-step solvers.
(default: RK2)</td>
</tr>
<tr class="row-even"><td>ml</td>
<td>Number of lower non-zero diagonals in a banded
Jacobian.</td>
</tr>
<tr class="row-odd"><td>ifactor</td>
<td>Maximum factor for increasing the step size (default:
2)</td>
</tr>
<tr class="row-even"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default:
0.0001)</td>
</tr>
<tr class="row-odd"><td>mu</td>
<td>Number of upper non-zero diagonals in a banded
Jacobian.</td>
</tr>
<tr class="row-even"><td>jac_f77</td>
<td><p class="first">Fortran subroutine for jac.
This subroutine has the signature:</p>
<div class="last highlight-python"><pre>      subroutine jac_f77
     1 (neq, t, u, ml, mu, pd, nrowpd)
Cf2py intent(hide) neq,ml,mu,nrowpd
Cf2py intent(out) pd
      integer neq,ml,mu,nrowpd
      double precision t,u,pd
      dimension u(neq),pd(neq,neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>ydoti</td>
<td>Real array for the initial value of dy/dt. (default:
[])</td>
</tr>
<tr class="row-odd"><td>strictdt</td>
<td>Uniform time mesh vs exact dt spacings (default: True)</td>
</tr>
<tr class="row-even"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver. (default: Picard)</td>
</tr>
<tr class="row-odd"><td>specialtimes</td>
<td>List of special times to use during iteration</td>
</tr>
<tr class="row-even"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept
in memory; if True, a default filename tmp_odspy.dat
is used. (default: False)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.MySolver.advance" title="odespy.solvers.MySolver.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.MySolver.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.MySolver.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.MySolver.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#MySolver.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.MySolver.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.RK2">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">RK2</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Standard Runge-Kutta 2nd method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])),</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.RK2.advance" title="odespy.solvers.RK2.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.RK2.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.RK2.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.RK2.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK2.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK2.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.RK2.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 2nd-order Runge-Kutta method'</em><a class="headerlink" href="#odespy.solvers.RK2.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.RK3">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">RK3</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>RungeKutta3 method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">K1</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">K2</span> <span class="o">+</span> <span class="n">K3</span><span class="p">)</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">K1</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="n">K2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">K1</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="n">K3</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">K1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">K2</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.RK3.advance" title="odespy.solvers.RK3.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.RK3.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.RK3.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.RK3.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK3.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK3.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.RK3.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 3rd-order Runge-Kutta method'</em><a class="headerlink" href="#odespy.solvers.RK3.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.RK34">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">RK34</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK34"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK34" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Adaptive" title="odespy.solvers.Adaptive"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Adaptive</span></tt></a></p>
<p>NOTE: This class does not work!</p>
<p>Adaptive 4th-order Runge-Kutta method.
For each time level t[n], the method takes many
adaptively chosen (small) time steps to hit the
next target level t[n+1].
All computed u and t values are available as
self.u_adaptive and self.t_adaptive, if desired.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.RK34.advance" title="odespy.solvers.RK34.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td>Advance from t[n] to t[n+1] in (small) adaptive steps.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.RK34.advance_intermediate" title="odespy.solvers.RK34.advance_intermediate"><tt class="xref py py-obj docutils literal"><span class="pre">advance_intermediate</span></tt></a>(u,&nbsp;t,&nbsp;dt)</td>
<td>Advance the solution an intermediate addaptive step.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.RK34.initialize_for_solve" title="odespy.solvers.RK34.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odespy.solvers.RK34.__init__">
<tt class="descname">__init__</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK34.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK34.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.RK34.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.RK34.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.RK34.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK34.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK34.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance from t[n] to t[n+1] in (small) adaptive steps.</p>
<p>Adaptivity logic:
Define <tt class="docutils literal"><span class="pre">h</span></tt> as the local adaptive time step and <tt class="docutils literal"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">t[1]-t[0]</span></tt>.
Start with <tt class="docutils literal"><span class="pre">h</span></tt> as <tt class="docutils literal"><span class="pre">first_step</span></tt> if <tt class="docutils literal"><span class="pre">first_step</span> <span class="pre">&lt;=</span> <span class="pre">dt</span></tt>,
otherwise <tt class="docutils literal"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">dt</span></tt>.
At each user-specified time level: step <tt class="docutils literal"><span class="pre">h</span></tt> forward, estimate
error, accept solution if error less than tolerance, adjust <tt class="docutils literal"><span class="pre">h</span></tt>,
retry with new <tt class="docutils literal"><span class="pre">h</span></tt> until solution is less than error.
Then proceed with a new step. Continue until next user-specified
time level.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.RK34.advance_intermediate">
<tt class="descname">advance_intermediate</tt><big>(</big><em>u</em>, <em>t</em>, <em>dt</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK34.advance_intermediate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK34.advance_intermediate" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the solution an intermediate addaptive step.
Parmeters: u at time t, dt is current step size.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.RK34.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK34.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK34.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.RK34.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Adaptive 4th-order Runge-Kutta method'</em><a class="headerlink" href="#odespy.solvers.RK34.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.RK4">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">RK4</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Standard RK4 method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">K1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">K2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">K3</span> <span class="o">+</span> <span class="n">K4</span><span class="p">)</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">K1</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="n">K2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">K1</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="n">K3</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">K2</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="n">K4</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">K3</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.RK4.advance" title="odespy.solvers.RK4.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.RK4.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.RK4.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.RK4.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RK4.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RK4.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.RK4.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 4th-order Runge-Kutta method'</em><a class="headerlink" href="#odespy.solvers.RK4.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.RKFehlberg">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">RKFehlberg</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RKFehlberg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RKFehlberg" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Adaptive" title="odespy.solvers.Adaptive"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Adaptive</span></tt></a></p>
<p>The classical adaptive Runge-Kutta-Fehlberg method of order 4-5.
The method is also available in more sophisticated form as
class Fehlberg (in the RungeKutta module).</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.RKFehlberg.advance" title="odespy.solvers.RKFehlberg.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.RKFehlberg.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.RKFehlberg.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.RKFehlberg.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#RKFehlberg.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.RKFehlberg.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.RKFehlberg.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Adaptive Runge-Kutta-Fehlberg (4,5) method'</em><a class="headerlink" href="#odespy.solvers.RKFehlberg.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.Solver">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">Solver</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Superclass for numerical methods solving ODE problem</p>
<blockquote>
<div>u&#8217;(t) = f(u, t),  u(0) = U0</div></blockquote>
<p>where u and U0 are scalars (for scalar ODEs) or vectors
(for systems of ODEs).</p>
<p>Attributes stored in this class:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>u</td>
<td>array of point values of the solution function</td>
</tr>
<tr class="row-odd"><td>t</td>
<td>array of time values: u[i] corresponds to t[i]</td>
</tr>
<tr class="row-even"><td>n</td>
<td>the most recently computed solution is u[n+1]</td>
</tr>
<tr class="row-odd"><td>f</td>
<td>function wrapping the user&#8217;s right-hand side f(u, t),
used in all algorithms</td>
</tr>
<tr class="row-even"><td>users_f</td>
<td>the user&#8217;s original function implementing f(u, t)</td>
</tr>
<tr class="row-odd"><td>PRM</td>
<td>an attribute for each optional and required parameter</td>
</tr>
</tbody>
</table>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Solver.adjust_parameters" title="odespy.solvers.Solver.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Solver.advance" title="odespy.solvers.Solver.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td>Advance solution one time step.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Solver.check_conditional_parameters" title="odespy.solvers.Solver.check_conditional_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt></a>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Solver.check_extra" title="odespy.solvers.Solver.check_extra"><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt></a>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Solver.check_input_range" title="odespy.solvers.Solver.check_input_range"><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt></a>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Solver.check_input_types" title="odespy.solvers.Solver.check_input_types"><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt></a>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Solver.compile_string_functions" title="odespy.solvers.Solver.compile_string_functions"><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt></a>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Solver.constant_time_step" title="odespy.solvers.Solver.constant_time_step"><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt></a>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Solver.get" title="odespy.solvers.Solver.get"><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt></a>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Solver.get_parameter_info" title="odespy.solvers.Solver.get_parameter_info"><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt></a>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Solver.has_u_t_all" title="odespy.solvers.Solver.has_u_t_all"><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt></a>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Solver.initialize" title="odespy.solvers.Solver.initialize"><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt></a>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Solver.initialize_for_solve" title="odespy.solvers.Solver.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Solver.set" title="odespy.solvers.Solver.set"><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt></a>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Solver.set_initial_condition" title="odespy.solvers.Solver.set_initial_condition"><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt></a>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Solver.solve" title="odespy.solvers.Solver.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Solver.switch_to" title="odespy.solvers.Solver.switch_to"><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt></a>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.Solver.validate_data" title="odespy.solvers.Solver.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odespy.solvers.Solver.__init__">
<tt class="descname">__init__</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">f</span></tt> is the right-hand side function of the ODE u&#8217; = f(u,t).
The legal keyword arguments (in <tt class="docutils literal"><span class="pre">kwargs</span></tt>) are documented in
the tables in the doc string of this class. The <tt class="docutils literal"><span class="pre">f</span></tt> function
must return a <tt class="docutils literal"><span class="pre">float</span></tt> or <tt class="docutils literal"><span class="pre">complex</span></tt> object in case of a
scalar ODE and a list or array of <tt class="docutils literal"><span class="pre">float</span></tt> or <tt class="docutils literal"><span class="pre">complex</span></tt> objects
in case of a system of ODEs.</p>
<p>This constructor makes a dictionary <tt class="docutils literal"><span class="pre">self._parameters</span></tt>
holding all the required and optional parameters for this solver
(fetched from the global <tt class="docutils literal"><span class="pre">_parameters</span></tt> dictionary in this module).
The method <tt class="docutils literal"><span class="pre">adjust_parameters</span></tt> (implemented in subclasses)
is called to adjust default parameter settings if needed.
Then all keys in <tt class="docutils literal"><span class="pre">self._parameters</span></tt> become class attributes,
filled with default values. Thereafter, all keyword arguments
(in <tt class="docutils literal"><span class="pre">kwargs</span></tt>) with <tt class="docutils literal"><span class="pre">None</span></tt> as value are removed as keyword
arguments. The next step is to call <tt class="docutils literal"><span class="pre">set(**kwargs)</span></tt>, i.e.,
use the keyword arguments to modify the values of the attributes
that represent the parameters in this solver. Finally, the
constructor calls the method <tt class="docutils literal"><span class="pre">initialize</span></tt> (to be implemeneted
in subclasses, e.g., for importing necessary modules for the solver).</p>
<p>Instead of supplying keyword arguments to this constructor, the
user can at any time call the <tt class="docutils literal"><span class="pre">set</span></tt> method with keyword
arguments in order to specify parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.Solver.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.Solver.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return solvername(f=..., param1=..., etc.).</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return solver name, plus parameters that are different from
their default values.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows subclasses to adjust (modify or add)
entries in the self._parameters dictionary.
The method is called from the constructor.</p>
<p>Further adjustments of self._parameters can be done in
initialize_for_solve when all data for the solver are available.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance solution one time step.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.check_conditional_parameters">
<tt class="descname">check_conditional_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.check_conditional_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.check_conditional_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to check whether conditional parameters are
provided when specified condition fulfilled.</p>
<p>This function is not intended for simple solvers.
So it is not called automatically in current solvers.py.
But for some complicated solvers as ones in ODEPACK, they
are very useful and convenient.</p>
<p>Future developers can apply these functions at appropriate
locations with corresponding property-setting in
adjust_parameters().</p>
<p>For example, in Lsode_ODEPACK, when iter_method is set to 4, it
indicates that ODEPACK would apply user-supplied banded Jacoabian
function in corrector iteration. Then we need to confirm either
&#8216;jac_banded&#8217; or &#8216;jac_fortran&#8217; is supplied. Besides, &#8216;ml&#8217; &amp; &#8216;mu&#8217; are
also necessary for iteration with banded Jacobian matrix.
Thus in order to confirm sufficient conditional inputs, we set
parameters[&#8216;iter_method&#8217;][&#8216;condition_list&#8217;] =</p>
<blockquote>
<div>{...,&#8216;4&#8217;: ((&#8216;jac_banded&#8217;,&#8217;jac_fortran&#8217;),ml,mu),...}</div></blockquote>
<p>In this function, we would check all the legal parameters with specified
condition-list, and make sure all the conditional parameters with
current value is supplied.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.check_extra">
<tt class="descname">check_extra</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.check_extra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.check_extra" title="Permalink to this definition">¶</a></dt>
<dd><p>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given
functions that performs consistency checks on the parameter.
This method runs the user-given function(s) on the relevant
set of parameters.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.check_input_range">
<tt class="descname">check_input_range</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.check_input_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.check_input_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all existing inputs are in right specified range.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.check_input_types">
<tt class="descname">check_input_types</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.check_input_types"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.check_input_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all existing inputs are of right specified type.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.compile_string_functions">
<tt class="descname">compile_string_functions</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.compile_string_functions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.compile_string_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile functions which are supplied as Fortran strings.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.constant_time_step">
<tt class="descname">constant_time_step</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.constant_time_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.constant_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self.t has a uniform partition.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.get">
<tt class="descname">get</tt><big>(</big><em>parameter_name=None</em>, <em>print_info=False</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of specified input parameters.
If parameter_name is None, return dict of all inputs.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.get_parameter_info">
<tt class="descname">get_parameter_info</tt><big>(</big><em>print_info=False</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.get_parameter_info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.get_parameter_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary containing all properties of all
legal parameters in current subclass (i.e., the parameters
in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</p>
<p>If <em>print_info</em> is <em>True</em>, the <tt class="docutils literal"><span class="pre">self._parameters</span></tt> dict
is pretty printed, otherwise it is returned.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.has_u_t_all">
<tt class="descname">has_u_t_all</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.has_u_t_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.has_u_t_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self.u_all and self.t_all, defined in
subclasses derived from Adaptive, are computed.
This function for testing is placed in class Solver so
that any class can check of intermediate time steps
have been computed and are available.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Subclass-specific initialization. Called from constructor.
Typical use: import modules needed in methods in the class
and provide error messages if modules are not installed.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Setting values of internal attributes to be used in iteration.</p>
<p>These internal attributes are ususally dependent on the values of
other attributes. For example, for Rkc, self.itol should be
initialized here as a flag to indicate whether self.atol is
supplied as scalar or sequence.</p>
<p>In subclasses, this function can be extended when required.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.set">
<tt class="descname">set</tt><big>(</big><em>strict=False</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign values to one or more parameters, specified as keyword
arguments.</p>
<p>The legal parameters that can be set are contained in the dict
self._parameters.</p>
<p>If strict is true, only registered parameter names are accepted,
otherwise unregistered parameters are ignored.</p>
<p>The provided parameters (keyword arguments in kwargs) are
first checked for legal type and legal range.</p>
<p>Types and ranges of attributes are defined in self._parameters,
which is initialized with default settings and optionally
modified in the adjust_parameters method.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.set_initial_condition">
<tt class="descname">set_initial_condition</tt><big>(</big><em>U0</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.set_initial_condition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.set_initial_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Function set_initial_condition() is used to set initial value of
independent variables.</p>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute discrete solution u of the ODE problem at time points
specified in the array time_points. An optional user-supplied
function <tt class="docutils literal"><span class="pre">terminate(u,</span> <span class="pre">t,</span> <span class="pre">step_no)</span></tt> can be supplied to
terminate the solution process (<tt class="docutils literal"><span class="pre">terminate</span></tt> returns True
or False) at some time earlier than <tt class="docutils literal"><span class="pre">time_points[-1]</span></tt>.</p>
<p>Most classes in this solver hierarchy inherit this <tt class="docutils literal"><span class="pre">solve</span></tt>
method and implement their special <tt class="docutils literal"><span class="pre">advance</span></tt> method to
advance the solution one step.
Some solver classes will implement their own <tt class="docutils literal"><span class="pre">solve</span></tt>
method, for instance if they wrap some underlying software
that has a suitable <tt class="docutils literal"><span class="pre">solve</span></tt> functionality.</p>
<p>The algorithm steps in this <tt class="docutils literal"><span class="pre">solve</span></tt> method goes as follows.
The initialize_for_solve method is called to initialize
various data needed in the solution process (self. u, for instance).
Thereafter, <tt class="docutils literal"><span class="pre">validate_data</span></tt> is called to perform a consistency
check on data. We are then ready for the core of the method:
the time loop.</p>
<dl class="docutils">
<dt>Output:</dt>
<dd>u            : array to hold solution values corresponding to points
t            : array to hold time values.Usually same as time_points</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.switch_to">
<tt class="descname">switch_to</tt><big>(</big><em>solver_target</em>, <em>print_info=False</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.switch_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.switch_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new solver instance which switch to another subclass with
same values of common attributes.</p>
<p><cite>solver_target</cite> is either as a string (class name) or
a class, i.e., <tt class="docutils literal"><span class="pre">RK4</span></tt> or <tt class="docutils literal"><span class="pre">'RK4'</span></tt>.
The <cite>kwargs</cite> arguments are optional parameters to
reset/supplement values of argmenters in the solver we switch to.
The instance of the target solver is returned.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">odespy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">:</span> <span class="o">-</span><span class="n">u</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">time_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">RK2</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;Normarized error with RK2 is </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u1</span> <span class="o">-</span> <span class="n">exact_u</span><span class="p">)</span>
<span class="go">Normarized error with RK2 is 0.0077317</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">switch_to</span><span class="p">(</span><span class="n">odespy</span><span class="o">.</span><span class="n">RKFehlberg</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-18</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u2</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;Normarized error with RKFehlberg is </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u2</span> <span class="o">-</span> <span class="n">exact_u</span><span class="p">)</span>
<span class="go">Normarized error with RKFehlberg is 8.55517e-08</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odespy.solvers.Solver.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Solver.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Solver.validate_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used for extra checking and validating of
attributes before the computations start.</p>
<p>This version checks that the <tt class="docutils literal"><span class="pre">time_points</span></tt> is correctly
set up. The function also check that all required parameters
are initialized. Subclass versions may introduce additional
tests and help.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.SolverImplicit">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">SolverImplicit</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#SolverImplicit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.SolverImplicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Super class for implicit methods for ODEs.
Existing solvers are: BackwardEuler, Backward2Step, ThetaRule</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept
in memory; if True, a default filename tmp_odspy.dat
is used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default:
None)</td>
</tr>
<tr class="row-even"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacobian.
(default: 0.0001)</td>
</tr>
<tr class="row-even"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver. (default: Picard)</td>
</tr>
<tr class="row-odd"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default: 25)</td>
</tr>
<tr class="row-even"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default:
0.0001)</td>
</tr>
<tr class="row-odd"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solution +
(1-r)*old_solution (default: 1.0)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.SolverImplicit.advance" title="odespy.solvers.SolverImplicit.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.SolverImplicit.initialize_for_solve" title="odespy.solvers.SolverImplicit.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.SolverImplicit.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.SolverImplicit.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.SolverImplicit.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#SolverImplicit.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.SolverImplicit.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.SolverImplicit.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#SolverImplicit.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.SolverImplicit.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.ThetaRule">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">ThetaRule</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#ThetaRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.ThetaRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.SolverImplicit" title="odespy.solvers.SolverImplicit"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.SolverImplicit</span></tt></a></p>
<p>This class implements the implicit theta-rule method for solving
ODEs. The method includes a parameter theta used to weight the
previous and new time step when evaluating the right-hand side:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">theta</span></tt> is a float in [0,1].</p>
<p>The nonlinear system is solved by Picard or Newton iteration.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept
in memory; if True, a default filename tmp_odspy.dat
is used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default:
None)</td>
</tr>
<tr class="row-even"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacobian.
(default: 0.0001)</td>
</tr>
<tr class="row-even"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver. (default: Picard)</td>
</tr>
<tr class="row-odd"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default: 25)</td>
</tr>
<tr class="row-even"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default:
0.0001)</td>
</tr>
<tr class="row-odd"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solution +
(1-r)*old_solution (default: 1.0)</td>
</tr>
<tr class="row-even"><td>theta</td>
<td>Weight in [0,1] used for &#8220;theta-rule&#8221; finite
difference approx. (default: 0.5)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.ThetaRule.Newton_system" title="odespy.solvers.ThetaRule.Newton_system"><tt class="xref py py-obj docutils literal"><span class="pre">Newton_system</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.ThetaRule.Picard_update" title="odespy.solvers.ThetaRule.Picard_update"><tt class="xref py py-obj docutils literal"><span class="pre">Picard_update</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odespy.solvers.ThetaRule.Newton_system">
<tt class="descname">Newton_system</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#ThetaRule.Newton_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.ThetaRule.Newton_system" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.ThetaRule.Picard_update">
<tt class="descname">Picard_update</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#ThetaRule.Picard_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.ThetaRule.Picard_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.ThetaRule.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.ThetaRule.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.ThetaRule.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Unified Forward/Backward Euler and Midpoint methods'</em><a class="headerlink" href="#odespy.solvers.ThetaRule.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.Trapezoidal">
<tt class="descclassname">odespy.solvers.</tt><tt class="descname">Trapezoidal</tt><a class="headerlink" href="#odespy.solvers.Trapezoidal" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#odespy.solvers.Heun" title="odespy.solvers.Heun"><tt class="xref py py-class docutils literal"><span class="pre">Heun</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="odespy.solvers.Vode">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">Vode</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Vode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Vode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.ode_scipy" title="odespy.solvers.ode_scipy"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.ode_scipy</span></tt></a></p>
<p>Wrapper for scipy.integrate.ode.vode, which is a wrapper for vode.f,
which intends to solve initial value problems of stiff or nonstiff
type. The well-known vode.f solver applies backward differential
formulae for iteration.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step. (default:
1000)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or &#8220;bdf&#8221;.
(default: adams)</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>Maximum order used by the integrator (&lt;= 12 for &#8220;adams&#8221;,
&lt;= 5 for &#8220;bdf&#8221;). (default: 4)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.Vode.initialize_for_solve" title="odespy.solvers.Vode.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.Vode.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.Vode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.Vode.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#Vode.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.Vode.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.Vode.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Adams/BDF Vode adaptive method (vode.f wrapper)'</em><a class="headerlink" href="#odespy.solvers.Vode.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="odespy.solvers.approximate_Jacobian">
<tt class="descclassname">odespy.solvers.</tt><tt class="descname">approximate_Jacobian</tt><big>(</big><em>f</em>, <em>u0</em>, <em>t0</em>, <em>h</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#approximate_Jacobian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.approximate_Jacobian" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute approximate Jacobian of fucntion f at current point (u0,t0).
Method: forward finite difference approximation with step
size h.
Output: a two-dimensional array holding the Jacobian matrix.</p>
</dd></dl>

<dl class="function">
<dt id="odespy.solvers.compile_f77">
<tt class="descclassname">odespy.solvers.</tt><tt class="descname">compile_f77</tt><big>(</big><em>*function_strings</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#compile_f77"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.compile_f77" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile a list of strings, each string containing a Fortran 77
subroutine (typically for f, jac, etc.).
Return the extension module if keyword argument
<cite>return_module=True</cite>, otherwise return the subroutines/functions
corresponding to the given strings (default).
The name of the extension module is <tt class="docutils literal"><span class="pre">tmp_callback</span></tt> and the
corresponding file (to be cleaned up) is <tt class="docutils literal"><span class="pre">tmp_callback.so</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="odespy.solvers.list_all_solvers">
<tt class="descclassname">odespy.solvers.</tt><tt class="descname">list_all_solvers</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#list_all_solvers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.list_all_solvers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all solver classes in this package, excluding superclasses.</p>
</dd></dl>

<dl class="function">
<dt id="odespy.solvers.list_available_solvers">
<tt class="descclassname">odespy.solvers.</tt><tt class="descname">list_available_solvers</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#list_available_solvers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.list_available_solvers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all available solver classes in this package.</p>
</dd></dl>

<dl class="function">
<dt id="odespy.solvers.list_not_suitable_complex_solvers">
<tt class="descclassname">odespy.solvers.</tt><tt class="descname">list_not_suitable_complex_solvers</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#list_not_suitable_complex_solvers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.list_not_suitable_complex_solvers" title="Permalink to this definition">¶</a></dt>
<dd><p>List all solvers that do not work for complex-valued ODEs.</p>
</dd></dl>

<dl class="class">
<dt id="odespy.solvers.lsoda_scipy">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">lsoda_scipy</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#lsoda_scipy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.lsoda_scipy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Adaptive" title="odespy.solvers.Adaptive"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Adaptive</span></tt></a></p>
<p>Wrapper of the scipy.integrate.odeint solver so that it can be
called from the <em>odespy</em> user interface.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>ml</td>
<td>Number of lower non-zero diagonals in a banded Jacobian.</td>
</tr>
<tr class="row-odd"><td>mu</td>
<td>Number of upper non-zero diagonals in a banded Jacobian.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>Advance solution one time step.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.lsoda_scipy.initialize" title="odespy.solvers.lsoda_scipy.initialize"><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.lsoda_scipy.solve" title="odespy.solvers.lsoda_scipy.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.lsoda_scipy.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.lsoda_scipy.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.lsoda_scipy.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#lsoda_scipy.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.lsoda_scipy.initialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.lsoda_scipy.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Wrapper of lsoda (scipy.integrate.odeint)'</em><a class="headerlink" href="#odespy.solvers.lsoda_scipy.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.lsoda_scipy.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#lsoda_scipy.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.lsoda_scipy.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.ode_scipy">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">ode_scipy</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#ode_scipy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.ode_scipy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Adaptive" title="odespy.solvers.Adaptive"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Adaptive</span></tt></a></p>
<p>Superclass wrapper for <tt class="docutils literal"><span class="pre">scipy.integrate.ode</span></tt> classes.
Existing solvers in subclasses are: <tt class="docutils literal"><span class="pre">Vode</span></tt>, <tt class="docutils literal"><span class="pre">Dopri5</span></tt>, <tt class="docutils literal"><span class="pre">Dop853</span></tt>.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step. (default:
1000)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.ode_scipy.advance" title="odespy.solvers.ode_scipy.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.ode_scipy.initialize" title="odespy.solvers.ode_scipy.initialize"><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.ode_scipy.initialize_for_solve" title="odespy.solvers.ode_scipy.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.ode_scipy.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.ode_scipy.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.ode_scipy.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#ode_scipy.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.ode_scipy.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.ode_scipy.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#ode_scipy.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.ode_scipy.initialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.ode_scipy.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#ode_scipy.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.ode_scipy.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.odefun_sympy">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">odefun_sympy</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#odefun_sympy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.odefun_sympy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Solver" title="odespy.solvers.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Solver</span></tt></a></p>
<p>Wrapper for the sympy.mpmath.odefun method, which applies a high-order
Taylor series method to solve ODEs.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>Advance solution one time step.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.odefun_sympy.initialize" title="odespy.solvers.odefun_sympy.initialize"><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.odefun_sympy.initialize_for_solve" title="odespy.solvers.odefun_sympy.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.odefun_sympy.solve" title="odespy.solvers.odefun_sympy.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td>The complete solve method must be overridded in this class since sympy.mpmath.odefun is such a solve method.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.odefun_sympy.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.odefun_sympy.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.odefun_sympy.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#odefun_sympy.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.odefun_sympy.initialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.odefun_sympy.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#odefun_sympy.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.odefun_sympy.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.odefun_sympy.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Very accurate high order Taylor method (from SymPy)'</em><a class="headerlink" href="#odespy.solvers.odefun_sympy.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.odefun_sympy.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#odefun_sympy.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.odefun_sympy.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>The complete solve method must be overridded in this class
since sympy.mpmath.odefun is such a solve method.</p>
<p>The class stores an attribute ufunc (return from odefun)
which can be used to evaluate u at any time point (ufunc(t)).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odespy.solvers.odelab">
<em class="property">class </em><tt class="descclassname">odespy.solvers.</tt><tt class="descname">odelab</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#odelab"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.odelab" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odespy.solvers.Adaptive" title="odespy.solvers.Adaptive"><tt class="xref py py-class docutils literal"><span class="pre">odespy.solvers.Adaptive</span></tt></a></p>
<p>Odespy wrapper for the odelab package.
Typical use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="o">-</span><span class="n">u</span>   <span class="c"># u&#39; = -u</span>
<span class="kn">import</span> <span class="nn">odespy</span><span class="o">,</span> <span class="nn">numpy</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">odelab</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">odelab_solver</span><span class="o">=</span><span class="s">&#39;Butcher&#39;</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">21</span><span class="p">))</span>
</pre></div>
</div>
<p>Odelab offers the following solvers (for parameter <tt class="docutils literal"><span class="pre">odelab_solver</span></tt>):
&#8216;ExplicitEuler&#8217;, &#8216;ExplicitTrapezoidal&#8217;, &#8216;ImplicitEuler&#8217;, &#8216;RungeKutta34&#8217;, &#8216;RungeKutta4&#8217;, &#8216;ImplicitEuler&#8217;, &#8216;AdamsBashforth1&#8217;, &#8216;Heun&#8217;, &#8216;Kutta38&#8217;, &#8216;Kutta4&#8217;</p>
<p>Note: ode15s is actually scipy&#8217;s vode code called with BDF order=5.
Odelab&#8217;s DAE methods are not yet supported (could be by proper
wrapping of f and g in an <tt class="docutils literal"><span class="pre">odelab.system.System</span> <span class="pre">object</span></tt>).</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE.</td>
</tr>
<tr class="row-odd"><td>odelab_solver</td>
<td>Name of Solver class in odelab (default: RungeKutta4)</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs).</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt>. (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued. (default: False)</td>
</tr>
<tr class="row-odd"><td>disk_storage</td>
<td>Indicates whether u is stored in memory or in file. If
string, it is the filename; if False or &#8220;&#8221;, u is kept in
memory; if True, a default filename tmp_odspy.dat is
used. (default: False)</td>
</tr>
<tr class="row-even"><td>verbose</td>
<td>Integer reflecting output of intermediate quantities.
(default: 0)</td>
</tr>
<tr class="row-odd"><td>u_exact</td>
<td>Function of t returning exact solution. (default: None)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>Relative tolerance for solution. (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>Absolute tolerance for solution. (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive
algorithm.</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-even"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm.</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du).
(default: None)</td>
</tr>
<tr class="row-even"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: ())</td>
</tr>
<tr class="row-odd"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span>
<span class="pre">*jac_args,**jac_kwargs)</span></tt>. (default: {})</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>Advance solution one time step.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_u_t_all</span></tt>()</td>
<td>Return True if self.u_all and self.t_all, defined in</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.odelab.initialize" title="odespy.solvers.odelab.initialize"><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odespy.solvers.odelab.initialize_for_solve" title="odespy.solvers.odelab.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odespy.solvers.odelab.solve" title="odespy.solvers.odelab.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td>The complete solve method must be overridded in this class since odelab.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra checking and validating of attributes before the computations start.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odespy.solvers.odelab.DAE_solvers">
<tt class="descname">DAE_solvers</tt><em class="property"> = ['SymplicticEuler', 'MultiRKDAE', 'RKDAE', 'Spark', 'Spark2', 'Spark3', 'Spark4']</em><a class="headerlink" href="#odespy.solvers.odelab.DAE_solvers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.odelab.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odespy.solvers'</em><a class="headerlink" href="#odespy.solvers.odelab.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.odelab.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#odelab.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.odelab.initialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.odelab.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#odelab.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.odelab.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.odelab.not_valid">
<tt class="descname">not_valid</tt><em class="property"> = ['SymplecticEuler', 'LDIRK343', 'LobattoIIIA', 'LobattoIIIB', 'LobattoIIIC', 'LobattoIIICs', 'LobattoIIID', 'MultiRKDAE', 'RKDAE', 'RadauIIA', 'RungeKutta', 'Spark', 'Spark2', 'Spark3', 'Spark4', 'AdamsBashforth', 'AdamsBashforth2', 'AdamsBashforth2e', 'Butcher', 'Butcher1', 'Butcher3', 'ExplicitGeneralLinear', 'GeneralLinear', 'Kutta', 'McLachlan', 'NonHolonomicEnergy', 'NonHolonomicEnergy0', 'NonHolonomicEnergyEMP', 'NonHolonomicLeapFrog', 'SymplecticEuler', 'ABLawson', 'ABLawson2', 'ABLawson3', 'ABLawson4', 'ABNorset4', 'Exponential', 'GenLawson45', 'HochOst4', 'Lawson4', 'LawsonEuler', 'Phi', 'Polynomial', 'RKMK4T']</em><a class="headerlink" href="#odespy.solvers.odelab.not_valid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.odelab.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'interface to all solvers in odelab'</em><a class="headerlink" href="#odespy.solvers.odelab.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odespy.solvers.odelab.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#odelab.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.odelab.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>The complete solve method must be overridded in this class
since odelab. is such a solve method.</p>
</dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.odelab.solver">
<tt class="descname">solver</tt><em class="property"> = 'RKMK4T'</em><a class="headerlink" href="#odespy.solvers.odelab.solver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odespy.solvers.odelab.solvers">
<tt class="descname">solvers</tt><em class="property"> = ['ExplicitEuler', 'ExplicitTrapezoidal', 'ImplicitEuler', 'RungeKutta34', 'RungeKutta4', 'ImplicitEuler', 'AdamsBashforth1', 'Heun', 'Kutta38', 'Kutta4']</em><a class="headerlink" href="#odespy.solvers.odelab.solvers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="odespy.solvers.table_of_parameters">
<tt class="descclassname">odespy.solvers.</tt><tt class="descname">table_of_parameters</tt><big>(</big><em>classname</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#table_of_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.table_of_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a table (in reST format) of the required parameters
in a class and a table of the optional parameters.
The returned string is typially appended to the doc string of
a solver class so that the user can easily see which parameters
that must and can be provided.</p>
</dd></dl>

<dl class="function">
<dt id="odespy.solvers.typeset_toc">
<tt class="descclassname">odespy.solvers.</tt><tt class="descname">typeset_toc</tt><big>(</big><em>toc</em><big>)</big><a class="reference internal" href="_modules/odespy/solvers.html#typeset_toc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odespy.solvers.typeset_toc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">Odespy API 0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Liwei Wang and Hans Petter Langtangen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>